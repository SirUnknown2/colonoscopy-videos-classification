# %% [code] {"jupyter":{"outputs_hidden":false},"execution":{"iopub.status.busy":"2022-04-27T05:35:19.413585Z","iopub.execute_input":"2022-04-27T05:35:19.413869Z","iopub.status.idle":"2022-04-27T05:35:19.419606Z","shell.execute_reply.started":"2022-04-27T05:35:19.413838Z","shell.execute_reply":"2022-04-27T05:35:19.418526Z"}}
from tqdm import tqdm
import pandas as pd
import numpy as np
import networkx as nx
import matplotlib.pyplot as plt
import tensorflow as tf
from numpy.linalg import eig
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense
from tensorflow.keras.layers import InputLayer
from tensorflow.keras.layers import Activation

# %% [code] {"jupyter":{"outputs_hidden":false},"execution":{"iopub.status.busy":"2022-04-27T05:35:27.537453Z","iopub.execute_input":"2022-04-27T05:35:27.537778Z","iopub.status.idle":"2022-04-27T05:35:27.603646Z","shell.execute_reply.started":"2022-04-27T05:35:27.537740Z","shell.execute_reply":"2022-04-27T05:35:27.602805Z"}}
data = pd.read_csv("../input/gastrointestinal-lesions/data.txt")
data = data
shape = data.shape
dimension = data.ndim
data.dtypes
data.head()

# %% [code] {"jupyter":{"outputs_hidden":false},"execution":{"iopub.status.busy":"2022-04-27T05:35:34.423629Z","iopub.execute_input":"2022-04-27T05:35:34.424177Z","iopub.status.idle":"2022-04-27T05:35:34.462092Z","shell.execute_reply.started":"2022-04-27T05:35:34.424142Z","shell.execute_reply":"2022-04-27T05:35:34.461392Z"}}
features = pd.read_csv("../input/gastrointestinal-lesions/data.txt")
features = features.T
class_label = pd.Series(features.index)
features.index = range(features.shape[0])
classes = np.zeros((features.shape[0], 3))
for i in range(classes.shape[0]):
    if 'adenoma' in class_label[i]:
        classes[i,0] = 1.0
        class_label[i] = 0
    elif 'serrated' in class_label[i]:
        classes[i,2] = 1.0
        class_label[i] = 2
    else:
        classes[i,1] = 1.0
        class_label[i] = 1
classes = {'adenoma': classes[:,0], 'hyperplasic': classes[:,1], 'serrated': classes[:,2]}
classes = pd.DataFrame(classes)
class_label = class_label.astype('int')
# class1 = [float(i==1) for i in class_label.iloc[:,0]]
# class2 = [float(i==2) for i in class_label.iloc[:,0]]
# class_label = class_label.to_numpy().flatten()

# %% [code] {"jupyter":{"outputs_hidden":false},"execution":{"iopub.status.busy":"2022-04-27T05:35:38.217572Z","iopub.execute_input":"2022-04-27T05:35:38.217841Z","iopub.status.idle":"2022-04-27T05:35:38.636552Z","shell.execute_reply.started":"2022-04-27T05:35:38.217813Z","shell.execute_reply":"2022-04-27T05:35:38.635699Z"}}
features2 = pd.DataFrame({})
for col in features.columns:
    if features[col].abs().max()==0:
        continue
    features[col] = (features[col] - features[col].mean())/features[col].abs().max()
features.isnull().values.any()
#     if features2[col].isnull().values.any():
#         print(features[col].abs().max())
# features.index = range(features.shape[0])
# np.where(features.isnull())
# print(features.iloc[0,170])

# %% [code] {"jupyter":{"outputs_hidden":false},"execution":{"iopub.status.busy":"2022-04-27T05:35:41.784111Z","iopub.execute_input":"2022-04-27T05:35:41.784897Z","iopub.status.idle":"2022-04-27T05:35:50.123379Z","shell.execute_reply.started":"2022-04-27T05:35:41.784850Z","shell.execute_reply":"2022-04-27T05:35:50.122577Z"}}
model = Sequential([
    
    InputLayer(input_shape=(features.shape[1])),
    
    Dense(7, activation='sigmoid'),
    
    Dense(5, activation='sigmoid'),
    
    Dense(3, activation='sigmoid')
])

model.compile(optimizer='Adam',
              loss='binary_crossentropy',
              metrics=['accuracy']
             )
model.fit(features, classes, epochs=500)

# %% [code] {"jupyter":{"outputs_hidden":false},"execution":{"iopub.status.busy":"2022-04-27T05:35:53.876125Z","iopub.execute_input":"2022-04-27T05:35:53.876437Z","iopub.status.idle":"2022-04-27T05:42:31.439672Z","shell.execute_reply.started":"2022-04-27T05:35:53.876403Z","shell.execute_reply":"2022-04-27T05:42:31.438694Z"}}
grad_sum = 0
for col_name in tqdm(features.columns):
    pointFrame = features.loc[:, features.columns != col_name]
    for i in features[col_name]:
        pointFrame[col_name] = i*np.ones(len(features.index))
        points = tf.Variable(pointFrame, dtype='float')
        with tf.GradientTape() as tape:
            pred = model(points, training=False)
        grads = tape.gradient(pred, points)
        grad_sum += grads.numpy()
saliency_order = np.argsort(sum(grad_sum))

# %% [code] {"jupyter":{"outputs_hidden":false}}
num_features = 250
salient_features = features.iloc[:,saliency_order[0:num_features]]
A = np.zeros((features.shape[0], features.shape[0]))
for i in features.index:
    for j in range(i):
        A[i,j] = np.linalg.norm(salient_features.iloc[i,:] - salient_features.iloc[j,:])
A = A + np.transpose(A)
p = np.median(A).astype('int')
# p = 1.5
A = (A < p)
A = A - np.eye(A.shape[0])

# %% [code] {"jupyter":{"outputs_hidden":false},"execution":{"iopub.status.busy":"2022-04-27T05:42:59.962520Z","iopub.execute_input":"2022-04-27T05:42:59.963062Z","iopub.status.idle":"2022-04-27T05:43:00.194600Z","shell.execute_reply.started":"2022-04-27T05:42:59.963016Z","shell.execute_reply":"2022-04-27T05:43:00.193261Z"}}
rows, cols = np.where(A==1)
edges = zip(rows.tolist(), cols.tolist())
G = nx.Graph()
G.add_edges_from(edges, node_size=1)

# %% [code] {"execution":{"iopub.status.busy":"2022-04-27T05:43:07.799533Z","iopub.execute_input":"2022-04-27T05:43:07.799828Z","iopub.status.idle":"2022-04-27T05:43:08.026522Z","shell.execute_reply.started":"2022-04-27T05:43:07.799796Z","shell.execute_reply":"2022-04-27T05:43:08.025544Z"}}
giant_component = G.subgraph(max(nx.connected_components(G), key=len))
color_map_GC = np.array([])
for node in G:
    if node in giant_component:
        color_map_GC = np.append(color_map_GC, 'blue')
    else:
        color_map_GC = np.append(color_map_GC, 'red')
nx.draw(G, node_color=color_map_GC)
plt.plot()

# %% [code] {"jupyter":{"outputs_hidden":false},"execution":{"iopub.status.busy":"2022-04-27T05:43:44.072730Z","iopub.execute_input":"2022-04-27T05:43:44.073018Z","iopub.status.idle":"2022-04-27T05:43:44.721479Z","shell.execute_reply.started":"2022-04-27T05:43:44.072987Z","shell.execute_reply":"2022-04-27T05:43:44.718533Z"}}
import matplotlib.pyplot as plt
   ...: from sklearn.datasets import make_blobs
   ...: from sklearn.cluster import KMeans
   ...: from sklearn.metrics import silhouette_score
   ...: from sklearn.preprocessing import StandardScaler

kmeans = KMeans(n_clusters=3)
kmeans.fit(salient_features)
print(kmeans.inertia_)
# print(kmeans.cluster_centers_)
# print(kmeans.n_iter_)
predicted_label = kmeans.labels_
print(predicted_label)
print(classes)

# %% [code] {"_kg_hide-output":false,"jupyter":{"outputs_hidden":false},"execution":{"iopub.status.busy":"2022-04-27T05:43:52.006547Z","iopub.execute_input":"2022-04-27T05:43:52.006813Z","iopub.status.idle":"2022-04-27T05:43:52.184003Z","shell.execute_reply.started":"2022-04-27T05:43:52.006785Z","shell.execute_reply":"2022-04-27T05:43:52.181809Z"}}
color_map = np.array([])
for node in G:
    if (predicted_label[node]==0):
        color_map = np.append(color_map, 'red')
    elif (predicted_label[node]==1):
        color_map = np.append(color_map, 'blue')
    else:
        color_map = np.append(color_map, 'yellow')
nx.draw(G, node_color=color_map)
plt.plot()